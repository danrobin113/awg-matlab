%eim_mode   Solve 2D waveguide cross section by effective index method.
%
% This function solves for the fundamental TE (or TM) mode fields using 
% effective index method.
%
%              |<   w   >|
%               _________           _____
%              |         |            ^
%  ___    _____|         |_____ 
%   ^                                 h
%   t                                  
%  _v_    _____________________     __v__
%
%          II  |    I    |  II
%
% INPUT:
% lambda    - free space wavelength
% w         - core width
% h         - core thickness
% t         - slab thickness
%               t < h  : rib waveguide
%               t == 0 : rectangular waveguide w x h
%               t == h : uniform slab of thickness t
% na        - (top) oxide cladding layer index of refraction
% nc        - (middle) core layer index of refraction
% ns        - (bottom) substrate layer index of refraction
% x (optional) - provide the x coordinate vectors
%
% OPTIONS:
% Polarisation - one of 'TE' or 'TM'
% Limits - limits for autogenerated coordinates
% Points - number of points for autogenerated coordinates
%
% OUTPUT:
% E, H  - cell array of x, y and z field components such that E = {Ex, Ey, Ez}.
% x     - coordinate vector
% neff  - effective index of the modes solved
%
% NOTE: it is possible to provide a function of the form n = @(lambda0) for 
% the refraction index which will be called using lambda0.
%
% AUTHOR: Daniel Robin (daniel.robin.1@ulaval.ca)

function [E,H,x,neff] = wgmode(lambda,w,h,t,na,nc,ns,varargin)
% TODO: add support for multimode calculation
    
    assert(t >= 0 && t <= h, "The slab thickness parameter must be within [0, h].")

    p = inputParser;
    addOptional(p,'x',[]);
    addParameter(p,'Polarisation','te',@(x)ismember(x,{'TE','te','TM','tm'}))
    addParameter(p,'Limits',[-3*w,3*w])
    addParameter(p,'Points',100)
    parse(p,varargin{:})
    opts = p.Results;
    
    if isempty(opts.x)
        x = linspace(opts.Limits(1), opts.Limits(2), opts.Points)';
    else
        x = opts.x(:);
    end
    
    nil = zeros(size(x));
    
    if upper(opts.Polarisation) == "TE"
        
        neff = wgindex(lambda, w, h, t, na, nc, ns, ...
            'Modes', 1, 'Polarisation', 'te');
        
        % solve slab mode in section I
        n_I = slabindex(lambda, h, na, nc, ns, ...
            'Modes', 1, 'Polarisation', 'te');

        % solve slab mode in section II
        if t > 0
            n_II = slabindex(lambda, t, na, nc, ns, ...
                'Modes', 1, 'Polarisation', 'te');
        else
            n_II = na;
        end

        % equivalent slab mode
        [Ek, Hk] = slabmode(lambda, w, n_II, n_I, n_II, x, ...
            'Modes', 1, 'Polarisation', 'tm');
        
        f = max(Ek(:,1,2));

        % assemble field components
        Ex = Ek(:,1,2) / f;
        Hy = -Hk(:,1,1) / f;
        Hz = -Hk(:,1,3) / f;
        
        E = {Ex, nil, nil};
        H = {nil, Hy, Hz};
    else
        
        neff = wgindex(lambda, w, h, t, na, nc, ns, ...
            'Modes', 1, 'Polarisation', 'tm');
        
        % solve slab mode in section I
        n_I = slabindex(lambda, h, na, nc, ns, ...
            'Modes', 1, 'Polarisation', 'tm');

        % solve slab mode in section II
        if t > 0
            n_II = slabindex(lambda, t, na, nc, ns, ...
                'Modes', 1, 'Polarisation', 'tm');
        else
            n_II = na;
        end

        % equivalent slab mode
        [Ek, Hk] = slabmode(lambda, w, n_II, n_I, n_II, x, ...
            'Modes', 1, 'Polarisation', 'te');

        % assemble field components
        Ey = Ek(:,1,1);
        Ez = Ek(:,1,3);
        Hx = -Hk(:,1,2);
        
        E = {nil, Ey, Ez};
        H = {Hx, nil, nil};    
    end

end
